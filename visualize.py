#!/usr/bin/env python3
"""
Transaction Visualization Tool

Creates waterfall and flow visualizations of the transaction data generated by txgen.py
"""

import os
import json
import plotly.graph_objects as go
import plotly.express as px
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from datetime import datetime
import networkx as nx

def load_transaction_data(data_dir='data'):
    """Load the generated transaction data"""
    with open(os.path.join(data_dir, 'all_transactions.json'), 'r') as f:
        transactions = json.load(f)
    return transactions

def create_sankey_diagram(transactions, output_file='sankey_flow.html'):
    """Create a Sankey diagram showing the flow of funds between wallets"""
    # Extract source, target, and value from transactions
    sources = []
    targets = []
    values = []
    dates = []
    
    wallet_map = {
        'A': 0,  # Invoice wallet
        'B': 1,  # Treasury wallet
        'C': 2,  # Checking wallet
        'external': 3,  # External entities
        'unknown': 4   # Unknown sources (for invoice transactions)
    }
    
    # Create nodes
    nodes = ['Invoicing Wallet', 'Treasury Wallet', 'Checking Wallet', 'External', 'Unknown']
    
    # Iterate through transactions to build Sankey data
    for tx in transactions:
        source = tx.get('wallet_from', tx.get('wallet', 'unknown'))
        target = tx.get('wallet_to', 'unknown')
        
        # Skip if source or target is unknown
        if source not in wallet_map or target not in wallet_map:
            continue
        
        # Add the flow
        sources.append(wallet_map[source])
        targets.append(wallet_map[target])
        values.append(tx.get('satoshis', 0) / 100000000)  # Convert to BTC
        dates.append(tx.get('date', ''))
    
    # Create Sankey diagram
    fig = go.Figure(data=[go.Sankey(
        node=dict(
            pad=15,
            thickness=20,
            line=dict(color="black", width=0.5),
            label=nodes,
            color="blue"
        ),
        link=dict(
            source=sources,
            target=targets,
            value=values,
            # Add hover information
            hovertemplate='%{value:.8f} BTC from %{source.label} to %{target.label}<extra></extra>'
        )
    )])
    
    fig.update_layout(
        title_text="Bitcoin Flow Between Wallets",
        font_size=12,
        height=800
    )
    
    # Save to HTML file
    fig.write_html(output_file)
    
    print(f"Sankey diagram saved to {output_file}")
    return fig

def create_transaction_timeline(transactions, output_file='transaction_timeline.html'):
    """Create a timeline visualization of transactions"""
    # Extract data for timeline
    df_data = []
    
    for tx in transactions:
        df_data.append({
            'date': tx.get('date', ''),
            'block_height': tx.get('block_height', 0),
            'type': tx.get('type', 'unknown'),
            'from': tx.get('wallet_from', tx.get('wallet', 'unknown')),
            'to': tx.get('wallet_to', 'unknown'),
            'amount_btc': tx.get('btc_amount', tx.get('satoshis', 0) / 100000000),
            'amount_usd': tx.get('usd_amount', 0)
        })
    
    df = pd.DataFrame(df_data)
    df['date'] = pd.to_datetime(df['date'])
    
    # Create a timeline visualization
    fig = px.scatter(
        df, 
        x='date', 
        y='amount_btc',
        color='type',
        size='amount_btc',
        hover_data=['from', 'to', 'block_height', 'amount_usd'],
        title='Transaction Timeline',
        labels={'amount_btc': 'Amount (BTC)', 'date': 'Date', 'type': 'Transaction Type'}
    )
    
    fig.update_layout(height=600)
    fig.write_html(output_file)
    
    print(f"Transaction timeline saved to {output_file}")
    return fig

def create_wallet_balance_waterfall(transactions, output_file='wallet_balance_waterfall.html'):
    """Create a waterfall chart showing wallet balances over time"""
    # Sort transactions by date and block height
    sorted_txs = sorted(transactions, key=lambda x: (x.get('date', ''), x.get('block_height', 0)))
    
    # Track balances over time
    balances = {'A': [], 'B': [], 'C': []}
    dates = []
    block_heights = []
    current_balances = {'A': 0, 'B': 0, 'C': 0}
    
    for tx in sorted_txs:
        source = tx.get('wallet_from', tx.get('wallet', 'unknown'))
        target = tx.get('wallet_to', 'unknown')
        amount = tx.get('satoshis', 0) / 100000000  # Convert to BTC
        date = tx.get('date', '')
        block_height = tx.get('block_height', 0)
        
        # Update balances based on transaction
        if source in current_balances:
            current_balances[source] -= amount
        
        if target in current_balances:
            current_balances[target] += amount
        
        # Save the state
        for wallet in current_balances:
            balances[wallet].append(current_balances[wallet])
        
        dates.append(date)
        block_heights.append(block_height)
    
    # Create DataFrame for plotting - use block height as a unique identifier
    df_data = {
        'date': dates,
        'block_height': block_heights
    }
    
    for wallet in balances:
        df_data[f'Wallet {wallet}'] = balances[wallet]
    
    df = pd.DataFrame(df_data)
    df['date'] = pd.to_datetime(df['date'])
    
    # Group by date and get the last balance for each day (to avoid duplicate dates issue)
    df = df.sort_values(['date', 'block_height'])
    
    # Create stacked area chart
    fig = px.area(
        df, 
        x='date', 
        y=[f'Wallet {w}' for w in balances.keys()],
        title='Wallet Balances Over Time',
        labels={'value': 'Balance (BTC)', 'date': 'Date', 'variable': 'Wallet'}
    )
    
    fig.update_layout(height=600)
    fig.write_html(output_file)
    
    print(f"Wallet balance waterfall saved to {output_file}")
    
    # Also create a cumulative balance chart
    total_balance = []
    for i in range(len(dates)):
        total = sum(balances[wallet][i] for wallet in balances)
        total_balance.append(total)
    
    df_total = pd.DataFrame({
        'date': pd.to_datetime(dates),
        'block_height': block_heights,
        'total_balance': total_balance
    })
    
    df_total = df_total.sort_values(['date', 'block_height'])
    
    fig_total = px.line(
        df_total,
        x='date',
        y='total_balance',
        title='Total Bitcoin Balance Over Time',
        labels={'total_balance': 'Total Balance (BTC)', 'date': 'Date'}
    )
    
    total_output_file = output_file.replace('wallet_balance_waterfall', 'total_balance')
    fig_total.write_html(total_output_file)
    print(f"Total balance chart saved to {total_output_file}")
    
    return fig

def create_transaction_network(transactions, output_file='transaction_network.html'):
    """Create a network graph visualization of transactions"""
    # Create a directed graph
    G = nx.DiGraph()
    
    # Add nodes for all wallets and external entities
    wallet_nodes = {'A': 'Invoicing', 'B': 'Treasury', 'C': 'Checking', 'external': 'External', 'unknown': 'Unknown'}
    for wallet_id, name in wallet_nodes.items():
        G.add_node(wallet_id, label=name, size=30)
    
    # Add transaction edges
    for tx in transactions:
        source = tx.get('wallet_from', tx.get('wallet', 'unknown'))
        target = tx.get('wallet_to', 'unknown')
        tx_type = tx.get('type', 'unknown')
        amount = tx.get('btc_amount', tx.get('satoshis', 0) / 100000000)
        
        # Skip self-loops and missing endpoints
        if source == target or source not in wallet_nodes or target not in wallet_nodes:
            continue
        
        # Add or update edge
        if G.has_edge(source, target):
            G[source][target]['weight'] += amount
            G[source][target]['count'] += 1
        else:
            G.add_edge(source, target, weight=amount, count=1, type=tx_type)
    
    # Convert to a format Plotly can use
    edge_x = []
    edge_y = []
    edge_text = []
    
    pos = {
        'A': (0, 1), 
        'B': (1, 0), 
        'C': (2, 1), 
        'external': (1.5, 2), 
        'unknown': (0, 2)
    }
    
    for edge in G.edges(data=True):
        source, target, data = edge
        x0, y0 = pos[source]
        x1, y1 = pos[target]
        
        # Add curved edges
        edge_x.append(x0)
        edge_x.append(x1)
        edge_x.append(None)
        edge_y.append(y0)
        edge_y.append(y1)
        edge_y.append(None)
        
        edge_text.append(f"{data['weight']:.8f} BTC ({data['count']} transactions)")
    
    edge_trace = go.Scatter(
        x=edge_x, y=edge_y,
        line=dict(width=1, color='#888'),
        hoverinfo='text',
        text=edge_text,
        mode='lines'
    )
    
    node_x = []
    node_y = []
    node_text = []
    
    # Calculate node sizes based on transaction volume
    node_sizes = []
    for node in G.nodes():
        x, y = pos[node]
        node_x.append(x)
        node_y.append(y)
        node_text.append(f"{wallet_nodes[node]} Wallet")
        
        # Calculate node size based on transaction volume
        total_in = sum(data['weight'] for u, v, data in G.in_edges(node, data=True))
        total_out = sum(data['weight'] for u, v, data in G.out_edges(node, data=True))
        node_sizes.append(30 + 10 * (total_in + total_out))  # Base size + volume-based increase
    
    node_trace = go.Scatter(
        x=node_x, y=node_y,
        mode='markers+text',
        text=[wallet_nodes[node] for node in G.nodes()],
        textposition="top center",
        hoverinfo='text',
        marker=dict(
            showscale=True,
            colorscale='YlGnBu',
            size=node_sizes,
            color=[i for i in range(len(node_sizes))],  # Color by index
            colorbar=dict(
                thickness=15,
                title='Node Index',  # Fixed: removed 'titleside'
                xanchor='left'
            ),
            line_width=2
        )
    )
    
    # Create figure
    fig = go.Figure(data=[edge_trace, node_trace],
                  layout=go.Layout(
                      title='Transaction Network',
                      showlegend=False,
                      hovermode='closest',
                      margin=dict(b=20, l=5, r=5, t=40),
                      xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
                      yaxis=dict(showgrid=False, zeroline=False, showticklabels=False)
                  ))
    
    fig.write_html(output_file)
    print(f"Transaction network visualization saved to {output_file}")
    return fig

def main():
    """Main function to create all visualizations"""
    print("Bitcoin Transaction Visualization Tool")
    print("-------------------------------------")
    
    # Load transaction data
    transactions = load_transaction_data()
    print(f"Loaded {len(transactions)} transactions")
    
    # Create directory for visualizations
    os.makedirs('visualizations', exist_ok=True)
    
    # Create various visualizations
    create_sankey_diagram(transactions, 'visualizations/sankey_flow.html')
    create_transaction_timeline(transactions, 'visualizations/transaction_timeline.html')
    create_wallet_balance_waterfall(transactions, 'visualizations/wallet_balance_waterfall.html')
    create_transaction_network(transactions, 'visualizations/transaction_network.html')
    
    print("\nAll visualizations have been created in the 'visualizations' directory.")

if __name__ == "__main__":
    main() 